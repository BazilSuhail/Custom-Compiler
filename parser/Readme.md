# C-Style Language Parser

A comprehensive recursive descent parser for a C-style programming language, built in C++. This parser works in conjunction with a custom lexical analyzer to parse source code and generate an Abstract Syntax Tree (AST).

## Project Overview
This Parser is a C++ implementation of a parser for a simplified, C-like programming language. The parser takes a sequence of tokens generated by a custom lexer and constructs an Abstract Syntax Tree (AST) representing the program's structure. It uses a Pratt parsing approach to handle expressions with proper operator precedence and supports a variety of language constructs, including variable declarations, functions, control flow statements, and enums. The parser is designed to be robust, with detailed error handling for invalid syntax, and produces a human-readable AST output for valid programs.

## Features

The parser supports the following features:

- **Program Structure**:
  - Requires an `include <main>` directive at the start of every program.
  - Supports global function declarations and a `main` function.
  - Allows multiple `include` directives for headers (e.g., `include "header.h"` or `include identifier`).

- **Data Types**:
  - Basic types: `int`, `float`, `double`, `char`, `bool`, `void`.
  - Literals: integer, floating-point, string, character, and boolean literals.

- **Declarations**:
  - Variable declarations with optional initialization (e.g., `int x = 42;`).
  - Constant declarations (e.g., `const int MAX = 100;`).
  - Enum declarations with optional values (e.g., `enum Color { RED, BLUE = 2 };`).

- **Statements**:
  - Control flow: `if`, `else`, `while`, `do-while`, `for`, `switch` (with `case` and `default`), `break`.
  - Function calls and `print` statements for output.
  - Return statements with optional expressions.
  - Block statements using `{}`.
  - Expression statements.

- **Expressions**:
  - Arithmetic operators: `+`, `-`, `*`, `/`, `%`.
  - Comparison operators: `==`, `!=`, `<`, `>`, `<=`, `>=`.
  - Logical operators: `&&`, `||`, `!`.
  - Assignment operator: `=`.
  - Increment and decrement: `++`, `--` (prefix and postfix, applicable to identifiers).
  - Function calls with zero or more arguments.
  - Unary operators: `-` (negation), `!` (logical NOT).
  - Parenthesized expressions for grouping.

- **Error Handling**:
  - Comprehensive error reporting with specific messages for issues like missing semicolons, unexpected tokens, invalid function call targets, and unclosed blocks.
  - Line and column information for error diagnostics.

- **Parsing Technique**:
  - Uses a top-down Pratt parser for expressions, ensuring correct operator precedence and associativity.
  - Supports recursive descent for statements and declarations.

## BNF Grammar

The following Backus-Naur Form (BNF) grammar defines the syntax of the toy language:

```bnf
program ::= include_main declaration*

include_main ::= "include" "<" "main" ">"

declaration ::= function_decl | main_decl | statement

function_decl ::= type identifier "(" [ param_list ] ")" block

main_decl ::= "main" block

param_list ::= param { "," param }*

param ::= type identifier

type ::= "int" | "float" | "double" | "char" | "bool" | "void"

statement ::= const_decl
            | enum_decl
            | var_decl
            | print_stmt
            | if_stmt
            | while_stmt
            | do_while_stmt
            | for_stmt
            | switch_stmt
            | return_stmt
            | block
            | expr_stmt
            | "break" ";"

const_decl ::= "const" type identifier "=" expression ";"

enum_decl ::= "enum" identifier "{" enum_member_list [ "," ] "}" ";"

enum_member_list ::= enum_member { "," enum_member }*

enum_member ::= identifier [ "=" expression ]

var_decl ::= type identifier [ "=" expression ] ";"

print_stmt ::= "print" "(" [ expression_list ] ")" ";"

if_stmt ::= "if" "(" expression ")" block [ "else" block ]

while_stmt ::= "while" "(" expression ")" block

do_while_stmt ::= "do" block "while" "(" expression ")" ";"

for_stmt ::= "for" "(" [ for_init ] ";" [ expression ] ";" [ expression ] ")" block

for_init ::= var_decl | expression

switch_stmt ::= "switch" "(" expression ")" "{" { case_block } [ default_block ] "}"

case_block ::= "case" expression block

default_block ::= "default" block

return_stmt ::= "return" [ expression ] ";"

block ::= "{" statement* "}"

expr_stmt ::= expression ";"

expression_list ::= expression { "," expression }*

expression ::= assign_expr

assign_expr ::= logical_or_expr [ "=" assign_expr ]

logical_or_expr ::= logical_and_expr { "||" logical_and_expr }*

logical_and_expr ::= equality_expr { "&&" equality_expr }*

equality_expr ::= relational_expr { ( "==" | "!=" ) relational_expr }*

relational_expr ::= additive_expr { ( "<" | ">" | "<=" | ">=" ) additive_expr }*

additive_expr ::= multiplicative_expr { ( "+" | "-" ) multiplicative_expr }*

multiplicative_expr ::= unary_expr { ( "*" | "/" | "%" ) unary_expr }*

unary_expr ::= postfix_expr
             | ( "-" | "!" ) unary_expr
             | ( "++" | "--" ) identifier

postfix_expr ::= primary_expr
               | postfix_expr "(" [ expression_list ] ")"
               | identifier ( "++" | "--" )

primary_expr ::= integer_literal
               | float_literal
               | string_literal
               | char_literal
               | bool_literal
               | identifier
               | "(" expression ")"

integer_literal ::= digit+

float_literal ::= digit+ "." digit* [ ( "e" | "E" ) [ "+" | "-" ] digit+ ]

string_literal ::= "\"" { any_char }* "\""

char_literal ::= "'" any_char "'"

bool_literal ::= "true" | "false"

identifier ::= letter ( letter | digit )*

digit ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

letter ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z" | "_"

any_char ::= letter | digit | symbol | whitespace
```

## Operator Precedence and Associativity

The parser uses a Pratt parsing approach to handle expressions, with the following precedence levels and associativity rules, as defined in the `Precedence` enum:

| Precedence Level | Operators                  | Associativity |
|------------------|----------------------------|---------------|
| 9 (CALL)         | `()`, `++` (postfix), `--` (postfix) | Left          |
| 8 (UNARY)        | `-` (unary), `!`, `++` (prefix), `--` (prefix) | Right         |
| 7 (FACTOR)       | `*`, `/`, `%`              | Left          |
| 6 (TERM)         | `+`, `-`                   | Left          |
| 5 (COMPARISON)   | `<`, `>`, `<=`, `>=`       | Left          |
| 4 (EQUALITY)     | `==`, `!=`                 | Left          |
| 3 (LOGICAL_AND)  | `&&`                       | Left          |
| 2 (LOGICAL_OR)   | `||`                       | Left          |
| 1 (ASSIGNMENT)   | `=`                        | Right         |
| 0 (LOWEST)       |                            | N/A           |

- **Notes**:
  - Function calls (`()`) and postfix increment/decrement (`++`, `--`) have the highest precedence.
  - Unary operators (`-`, `!`, prefix `++`, `--`) are right-associative to allow chaining (e.g., `!!x`).
  - Assignment (`=`) is right-associative to support expressions like `a = b = 42`.
  - All binary operators (`+`, `-`, `*`, `/`, `%`, `==`, `!=`, `<`, `>`, `<=`, `>=`, `&&`, `||`) are left-associative.

## Example Code Snippets

Below are example programs that demonstrate the language's syntax and the parserâ€™s capabilities, followed by incorrect examples with expected errors.

### Correct Examples

#### Example 1: Simple Main Function with Variable Declaration
```c
include <main>
int main {
    int x = 42;
    print(x);
    return 0;
}
```
**Description**: Declares a variable `x`, prints it, and returns 0. The parser generates an AST with a `MainDecl` node containing a `VarDecl` and `PrintStmt`.

#### Example 2: Function with For Loop and Enum
```c
include <main>
enum Color { RED, GREEN = 2, BLUE };
int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result = result * i;
    }
    return result;
}
int main {
    print(factorial(5));
    return 0;
}
```
**Description**: Defines an `enum`, a `factorial` function with a `for` loop, and a `main` function that calls `factorial`. The parser handles the enum declaration, function declaration, loop, and function call correctly.

#### Example 3: Switch Statement
```c
include <main>
int main {
    int x = 2;
    switch (x) {
        case 1 { print("One"); }
        case 2 { print("Two"); }
        default { print("Other"); }
    }
    return 0;
}
```
**Description**: Uses a `switch` statement with `case` and `default` blocks. The parser correctly parses the switch expression and block-based case statements.

### Incorrect Examples and Errors

#### Incorrect Example 1: Missing `include <main>`
```c
int main {
    return 0;
}
```
**Error**: `Parse Error: Unexpected token: T_MAIN at line 1, column 1`
**Explanation**: The parser requires an `include <main>` directive as the first token, as enforced in `parseProgram`. Without it, a `T_MAIN` token triggers an `UnexpectedToken` error.

#### Incorrect Example 2: Missing Semicolon
```c
include <main>
int main {
    int x = 42
    return 0;
}
```
**Error**: `Parse Error: Missing semicolon at end of statement at line 3, column 14`
**Explanation**: The `parseVariableDeclaration` method expects a semicolon after a variable declaration. Missing it causes a `MissingSemicolon` error.

#### Incorrect Example 3: Invalid Function Call Target
```c
include <main>
int main {
    42();
    return 0;
}
```
**Error**: `Parse Error: Invalid function call target: only identifiers can be called at line 3, column 5`
**Explanation**: The `parseCallExpression` method checks that the callee is an identifier. Attempting to call a literal (`42`) triggers an `InvalidCallTarget` error.

#### Incorrect Example 4: Unclosed Block
```c
include <main>
int main {
    int x = 42;
    {
        print(x);
}
```
**Error**: `Parse Error: Unclosed block, expected '}' before end of file at line 6, column 1`
**Explanation**: The `parseBlock` method expects a closing `}` for every `{`. An unclosed block results in an `UnclosedBlock` error when `T_EOF` is encountered.

## Usage

1. **Input**: The parser expects tokens in a file (e.g., `tokens.txt`) with the format: `TOKEN_TYPE(value, line, column)`. The `loadTokens` function reads these tokens.
2. **Running**: Compile and run the C++ program with a token file as input. The parser will output the AST for valid programs or an error message for invalid ones.
3. **Extending**: Add new token types to the `TokenType` enum and update the parserâ€™s methods to support additional syntax.

# C++ Lexer and Parser Project

This project contains a custom lexer and parser for a simplified programming language, supporting tokens like `++`, `--`, loops, conditionals, and expressions.

---

## How to Run

1. Install **GCC** on Windows (e.g., via [MinGW](https://www.mingw-w64.org/downloads/)).  
   Confirm installation by running in Command Prompt:
```
gcc --version
```

2. Open the project folder in Command Prompt and run:
```
run
```

This will compile and execute the lexer and parser automatically using the `run.bat` script.


#### Dependencies

- C++ Standard Library (C++11 or later)
- No external libraries required

---

## ðŸ‘¥ Group Members

| Name      | Roll No | Folder       |
|-----------|---------|--------------|
| Abdullah  | 54      | `abdullah-54/` |
| Ahmad     | 78      | `ahmad-78/`   |
| Arshad    | 69      | `arshad-69/`  |
| Bazil     | 72      | `bazil-72/`   |

> Each member maintains their implementation inside their respective folder and branch.

---