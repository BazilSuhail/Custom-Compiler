# Custom Compiler â€“ Parser Project

This repository extends our **Compiler Construction course project** with a **Parser** phase.  
The parser consumes the **token stream** generated by the lexer and constructs an **Abstract Syntax Tree (AST)** using **recursive-descent parsing**.  

---

## ðŸ“‚ Repository Structure

The project follows the same structure as the **lexer** phase:  
Each group member maintains their implementation inside a personal folder, under a shared `parser` branch.

```
.
â”œâ”€â”€ abdullah-54/
â”œâ”€â”€ ahmad-78/
â”œâ”€â”€ arshad-69/
â””â”€â”€ bazil-72/
â””â”€â”€ screenshots/
```

Each folder contains:
- **`parser.cpp`** â†’ Main parser implementation (recursive-descent + Pratt expressions)
- **`ast.cpp` / `ast.h`** â†’ AST node definitions and pretty-printer  
- **`main.cpp`** â†’ Driver that loads tokens (from lexer or mock stream) and prints AST  

---

## âœ¨ Features of the Parser

1. **Recursive-Descent Parsing**
   - Handles **function declarations**, **compound statements**, **if/else**, **loops**, and **return statements**.
   - Grammar rules are encoded as C++ functions.

2. **Expression Parsing**
   - Pratt parser (precedence climbing) used for:
     * Arithmetic: `+ - * / %`
     * Relational: `< > <= >= == !=`
     * Logical: `&& || !`
     * Assignment: `= += -=`
   - Correctly handles **operator precedence** and **associativity**.

3. **AST Construction**
   - Produces AST nodes for:
     * Literals (int, float, string, char, bool)
     * Identifiers
     * Unary / Binary operations
     * Function calls
     * Statements (return, expression statements, blocks)
   - AST can be **pretty-printed** for debugging.

4. **Error Handling**
   - Returns clear error messages for invalid syntax using the following variants:

```
enum class ParseError {
    UnexpectedEOF,
    FailedToFindToken,
    ExpectedTypeToken,
    ExpectedIdentifier,
    UnexpectedToken,
    ExpectedFloatLit,
    ExpectedIntLit,
    ExpectedStringLit,
    ExpectedBoolLit,
    ExpectedExpr,
};
```

---

## ðŸ–¥ï¸ Example

### Input Token Stream (from lexer):
```
T_INT("int"), T_IDENTIFIER("main"), T_LPAREN("("), T_RPAREN(")"), 
T_LBRACE("{"), T_RETURN("return"), T_INTLIT("0"), T_SEMICOLON(";"), T_RBRACE("}")
```

### Output AST:
```
FunctionDecl(main)
  Block
    Return
      Literal(0)
```

---

## ðŸš€ How to Run

1. Clone the repository:
   ```bash
   git clone https://github.com/BazilSuhail/Custom-Compiler
   cd Custom-Compiler
   ```

2. Switch to the `parser` branch:
   ```bash
   git checkout parser
   ```

3. Navigate to a memberâ€™s folder.

4. Build and run:
   ```bash
   g++ -std=c++17 parser.cpp ast.cpp main.cpp -o parser
   ./parser
   ```

---

## ðŸ“– Notes

- The **recursive-descent parser** makes grammar rules explicit and easy to debug.  
- The **Pratt parser** elegantly handles operator precedence and associativity.  
- The parser is designed to work directly with the token stream output of the lexer phase.  

---

## ðŸ‘¥ Group Members

| Name      | Roll No | Folder       |
|-----------|---------|--------------|
| Abdullah  | 54      | `abdullah-54/` |
| Ahmad     | 78      | `ahmad-78/`   |
| Arshad    | 69      | `arshad-69/`  |
| Bazil     | 72      | `bazil-72/`   |

> Each member maintains their parser implementation inside their respective folder and branch.

---

**Maintained by Group Members (Abdullah-54, Ahmad-78, Arshad-69, Bazil-72)**  
Compiler Construction Course â€“ 2025
