# Custom Compiler â€“ Parser Project

This repository extends our **Compiler Construction course project** with a **Parser** phase.  
The parser consumes the **token stream** generated by the lexer and constructs an **Abstract Syntax Tree (AST)** using **recursive-descent parsing**.  

---

## ðŸ“‚ Repository Structure

The project follows the same structure as the **lexer** phase:  
Each group member maintains their implementation inside a personal folder, under a shared `parser` branch.

```
.
â”œâ”€â”€ abdullah-54/
â”œâ”€â”€ ahmad-78/
â”œâ”€â”€ arshad-69/
â””â”€â”€ bazil-72/
â””â”€â”€ screenshots/
```

Each folder contains:
- **`parser.cpp`** â†’ Main parser implementation (recursive-descent + Pratt expressions)
- **`ast.cpp` / `ast.h`** â†’ AST node definitions and pretty-printer  
- **`main.cpp`** â†’ Driver that loads tokens (from lexer or mock stream) and prints AST  

---

## âœ¨ Features of the Parser

1. **Recursive-Descent Parsing**
   - Handles **function declarations**, **compound statements**, **if/else**, **loops**, and **return statements**.
   - Grammar rules are encoded as C++ functions.

2. **Expression Parsing**
   - Pratt parser (precedence climbing) used for:
     * Arithmetic: `+ - * / %`
     * Relational: `< > <= >= == !=`
     * Logical: `&& || !`
     * Assignment: `= += -=`
   - Correctly handles **operator precedence** and **associativity**.

3. **AST Construction**
   - Produces AST nodes for:
     * Literals (int, float, string, char, bool)
     * Identifiers
     * Unary / Binary operations
     * Function calls
     * Statements (return, expression statements, blocks)
   - AST can be **pretty-printed** for debugging.

4. **Error Handling**
   - Returns clear error messages for invalid syntax using the following variants:

```
enum class ParseError {
    UnexpectedEOF,
    FailedToFindToken,
    ExpectedTypeToken,
    ExpectedIdentifier,
    UnexpectedToken,
    ExpectedFloatLit,
    ExpectedIntLit,
    ExpectedStringLit,
    ExpectedBoolLit,
    ExpectedExpr,
};
```

---

## ðŸ–¥ï¸ Example

### Input Token Stream (from lexer):
```
T_INT("int"), T_IDENTIFIER("main"), T_LPAREN("("), T_RPAREN(")"), 
T_LBRACE("{"), T_RETURN("return"), T_INTLIT("0"), T_SEMICOLON(";"), T_RBRACE("}")
```

### Output AST:
```
FunctionDecl(main)
  Block
    Return
      Literal(0)
```

---

## ðŸš€ How to Run

1. Clone the repository:
   ```bash
   git clone https://github.com/BazilSuhail/Custom-Compiler
   cd Custom-Compiler
   ```

2. Switch to the `parser` branch:
   ```bash
   git checkout parser
   ```

3. Navigate to a memberâ€™s folder.

4. Build and run:
   ```bash
   g++ -std=c++17 parser.cpp ast.cpp main.cpp -o parser
   ./parser
   ```

---

## ðŸ“– Notes

- The **recursive-descent parser** makes grammar rules explicit and easy to debug.  
- The **Pratt parser** elegantly handles operator precedence and associativity.  
- The parser is designed to work directly with the token stream output of the lexer phase.  

---

## ðŸ‘¥ Group Members

| Name      | Roll No | Folder       |
|-----------|---------|--------------|
| Abdullah  | 54      | `abdullah-54/` |
| Ahmad     | 78      | `ahmad-78/`   |
| Arshad    | 69      | `arshad-69/`  |
| Bazil     | 72      | `bazil-72/`   |

> Each member maintains their parser implementation inside their respective folder and branch.

---

## Pratt Parser Grammer:

```

program     â†’ { declaration } ;

declaration â†’ variable_decl | function_decl | main_decl ;

variable_decl â†’ type IDENTIFIER [ "=" expression ] ";" ;

function_decl â†’ type IDENTIFIER "(" [ parameter_list ] ")" block ;

parameter_list â†’ parameter { "," parameter } ;

parameter     â†’ type IDENTIFIER ;

main_decl     â†’ "main" block ;

block         â†’ "{" { statement } "}" ;

statement     â†’ expression_stmt
              | print_stmt
              | if_stmt
              | while_stmt
              | return_stmt
              | block
              | variable_decl ;

expression_stmt â†’ [ expression ] ";" ;

print_stmt    â†’ "print" "(" [ expression_list ] ")" ";" ;

expression_list â†’ expression { "," expression } ;

if_stmt       â†’ "if" "(" expression ")" statement [ "else" statement ] ;

while_stmt    â†’ "while" "(" expression ")" statement ;

return_stmt   â†’ "return" [ expression ] ";" ;

expression    â†’ assignment ;

assignment    â†’ IDENTIFIER "=" assignment
              | logical_or ;

logical_or    â†’ logical_and { "||" logical_and } ;

logical_and   â†’ equality { "&&" equality } ;

equality      â†’ comparison { ( "==" | "!=" ) comparison } ;

comparison    â†’ term { ( "<" | ">" | "<=" | ">=" ) term } ;

term          â†’ factor { ( "+" | "-" ) factor } ;

factor        â†’ unary { ( "*" | "/" | "%" ) unary } ;

unary         â†’ ( "!" | "-" ) unary
              | primary ;

primary       â†’ IDENTIFIER
              | literal
              | "(" expression ")"
              | IDENTIFIER "(" [ argument_list ] ")" ;  // function call

argument_list â†’ expression { "," expression } ;

literal       â†’ INTLIT | FLOATLIT | STRINGLIT | CHARLIT | BOOLLIT ;

```

---

**Maintained by Group Members (Abdullah-54, Ahmad-78, Arshad-69, Bazil-72)**  
Compiler Construction Course â€“ 2025
