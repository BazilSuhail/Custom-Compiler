# Custom Compiler ‚Äì Pratt Parser

This repository extends our **Compiler Construction course project** with the **Pratt Parser** phase.  
The parser consumes the **token stream** generated by the lexer and constructs an **Abstract Syntax Tree (AST)** using Pratt parsing with recursive-descent support for statements.

---

## üìÇ Repository Structure

Each group member maintains their implementation inside a personal folder under the shared `parser` branch.

```
.
‚îú‚îÄ‚îÄ abdullah-54/
‚îú‚îÄ‚îÄ ahmad-78/
‚îú‚îÄ‚îÄ arshad-69/
‚îú‚îÄ‚îÄ bazil-72/
‚îú‚îÄ‚îÄ lexical-analyzer/
‚îî‚îÄ‚îÄ screenshots/
```

Each group-member folder contains:
- **`*.cpp`** ‚Üí Parser implementation ( eveyone's own implementation and code)

**lexical-analyzer** folder contains:
- **`lexer.cpp`** ‚Üí Original Lexer implementation
- **`custom-lexer.cpp`** ‚Üí Custom Lexer's implementation to read code from a file and producde token in a file also
---

## ‚ú® Features

- **Include Directive**
  - Supports `include<main>` at the top of the file.

- **Main Entry Point**
  - Declared with `main { ... }`.

- **Functions**
  - Declaration syntax: `<type> name(type param, ...) { ... }`.  
  - Return statements with optional expression.

- **Statements**
  - Variable declarations with optional initializer.  
  - Assignments with semicolons.  
  - Print statements with multiple arguments.  
  - If/Else statements with block bodies.  
  - While loops with block bodies.  
  - Blocks `{ ... }` containing multiple statements.  

- **Expressions**
  - Literals: int, float, char, string, bool.  
  - Identifiers.  
  - Binary operations (`+ - * / % < > <= >= == != && ||`).  
  - Unary operations (`-`, `!`).  
  - Function calls (`f(expr, ...)`) with identifier callees only.  

- **Semantics / Constraints**
  - Each statement must end with `;` unless it is a block.  
  - Blocks must close with `}` or report *Unclosed block*.  
  - Only identifiers can be used as function call targets.  
  - Assignment requires an identifier on the left-hand side.  
  - Chained assignment is not supported.  
  - `print` is a reserved statement, not a general function.  

---

## üìñ Grammar (BNF)

```
program        ::= top-level* EOF

top-level      ::= include-stmt
                 | function-decl
                 | main-decl
                 | statement

include-stmt   ::= "include" "<" "main" ">"

function-decl  ::= type IDENTIFIER "(" param-list? ")" block
param-list     ::= param ("," param)*
param          ::= type IDENTIFIER

main-decl      ::= "main" block

statement      ::= var-decl
                 | print-stmt
                 | if-stmt
                 | while-stmt
                 | return-stmt
                 | block
                 | expression-stmt

var-decl       ::= type IDENTIFIER ("=" expression)? ";"
print-stmt     ::= "print" "(" arg-list? ")" ";"
if-stmt        ::= "if" "(" expression ")" block ("else" block)?
while-stmt     ::= "while" "(" expression ")" block
return-stmt    ::= "return" expression? ";"
expression-stmt ::= expression ";"

block          ::= "{" statement* "}"
arg-list       ::= expression ("," expression)*

expression     ::= assignment
assignment     ::= IDENTIFIER "=" expression
                 | logical-or
logical-or     ::= logical-and ( "||" logical-and )*
logical-and    ::= equality ( "&&" equality )*
equality       ::= comparison ( ("==" | "!=") comparison )*
comparison     ::= term ( ("<" | ">" | "<=" | ">=") term )*
term           ::= factor ( ("+" | "-") factor )*
factor         ::= unary ( ("*" | "/" | "%") unary )*
unary          ::= ("-" | "!") unary | postfix
postfix        ::= IDENTIFIER "(" arg-list? ")" | primary
primary        ::= INTLIT | FLOATLIT | STRINGLIT | CHARLIT | BOOLLIT | IDENTIFIER | "(" expression ")"

type           ::= "int" | "float" | "double" | "char" | "bool" | "void"
```

---

## ‚öñÔ∏è Operator Precedence and Associativity

| Level | Operators | Associativity | Notes |
|-------|-----------|---------------|-------|
| 9 | Function call `()` | Left | Callee must be IDENTIFIER only |
| 8 | Unary `-`, `!` | Right | Prefix operators |
| 7 | `*`, `/`, `%` | Left | Multiplicative |
| 6 | `+`, `-` | Left | Additive |
| 5 | `<`, `>`, `<=`, `>=` | Left | Relational |
| 4 | `==`, `!=` | Left | Equality |
| 3 | `&&` | Left | Logical AND |
| 2 | `\|\|` | Left | Logical OR |
| 1 | `=` | Right | Assignment, left side must be IDENTIFIER |

---

## ‚ùå Error Handling

- **MissingSemicolon** ‚Üí Statement missing `;`.  
- **UnclosedBlock** ‚Üí EOF before closing `}`.  
- **InvalidCallTarget** ‚Üí Function call target not an identifier.  
- **UnexpectedToken** ‚Üí Token does not match grammar rule.  

---

## üñ•Ô∏è Example

### Valid Program
```
include<main>

int add(int a, int b) {
    return a + b;
}

main {
    int x = 10;
    print("Hello World!\n");

    if (x > 5) {
        x = add(x, 2);
    }

    while (x > 0) {
        print("x = ", x, "\n");
        x = x - 1;
    }

    { int z = 5; }
    return 0;
}
```

### Parsed AST:
```
IncludeStmt("main")
FunctionDecl(int, "add")
  Param: int a
  Param: int b
  Body:
    ReturnStmt
      BinaryExpr(+)
        Identifier("a")
        Identifier("b")
MainDecl
  VarDecl(int, "x")
    IntLiteral(10)
  PrintStmt
    StringLiteral("Hello World!\n")
  IfStmt
    Condition:
      BinaryExpr(>)
        Identifier("x")
        IntLiteral(5)
    IfBody:
      ExpressionStmt
        BinaryExpr(=)
          Identifier("x")
          CallExpr
            Callee:
              Identifier("add")
            Args:
              Identifier("x")
              IntLiteral(2)
  WhileStmt
    Condition:
      BinaryExpr(>)
        Identifier("x")
        IntLiteral(0)
    Body:
      PrintStmt
        StringLiteral("x = ")
        Identifier("x")
        StringLiteral("\n")
      ExpressionStmt
        BinaryExpr(=)
          Identifier("x")
          BinaryExpr(-)
            Identifier("x")
            IntLiteral(1)
  BlockStmt
    VarDecl(int, "z")
      IntLiteral(5)
  ReturnStmt
    IntLiteral(0)
```

---

### Invalid Program (missing `;`)
```
int x = 10
print(x);
```
Error: `Missing semicolon at end of statement`.

### Invalid Function Call
```
(x+1)(2);
```
Error: `Invalid function call target: only identifiers can be called`.

---

## üöÄ How to Run

1. Clone the repository:
   ```bash
   git clone https://github.com/BazilSuhail/Custom-Compiler
   cd Custom-Compiler
   ```
2. Switch to the parser branch:
   ```bash
   git checkout parser
   ```
3. Navigate to a member‚Äôs folder.  
4. Build and run:
   ```bash
   g++ -std=c++17 parser.cpp ast.cpp main.cpp -o parser
   ./parser
   ```

---

## üë• Group Members

| Name      | Roll No | Folder       |
|-----------|---------|--------------|
| Abdullah  | 54      | `abdullah-54/` |
| Ahmad     | 78      | `ahmad-78/`   |
| Arshad    | 69      | `arshad-69/`  |
| Bazil     | 72      | `bazil-72/`   |

---

**Maintained by Group Members (Abdullah-54, Ahmad-78, Arshad-69, Bazil-72)**  
Compiler Construction Course ‚Äì 2025  
