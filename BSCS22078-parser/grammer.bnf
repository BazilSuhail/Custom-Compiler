program         ::= declaration* EOF ;

declaration     ::= includeDirective
                  | enumDecl
                  | varDecl
                  | fnDecl
                  | statement ;

varDecl         ::= typeSpec IDENTIFIER ( "=" expression )? ";" ;

fnDecl          ::= typeSpec ID     ENTIFIER "(" parameters? ")" block ;

parameters      ::= parameter ( "," parameter )* ;

parameter       ::= typeSpec IDENTIFIER ;

typeSpec        ::= typeQualifier? baseType ;

typeQualifier   ::= "const" ;

baseType        ::= "int" | "float" | "double" | "char" | "bool" | "void" ;

includeDirective ::= "#include" ( "<" IDENTIFIER ( "." IDENTIFIER )? ">" 
                                | STRINGLIT ) ;

enumDecl        ::= "enum" IDENTIFIER "{" enumValueList? "}" ";" ;

enumValueList   ::= IDENTIFIER ( "," IDENTIFIER )* ;

statement       ::= returnStmt
                  | ifStmt
                  | whileStmt
                  | doWhileStmt
                  | forStmt
                  | switchStmt
                  | breakStmt
                  | continueStmt
                  | assignStmt
                  | exprStmt ;

assignStmt      ::= IDENTIFIER "=" expression ";" ;

returnStmt      ::= "return" expression? ";" ;

breakStmt       ::= "break" ";" ;

continueStmt    ::= "continue" ";" ;

ifStmt          ::= "if" "(" expression ")" block ("else" block)? ;

whileStmt       ::= "while" "(" expression ")" block ;

doWhileStmt     ::= "do" block "while" "(" expression ")" ";" ;

forStmt         ::= "for" "(" ( varDecl | exprStmt | ";" ) 
                        expression? ";" 
                        expression? ")" block ;

switchStmt      ::= "switch" "(" expression ")" "{" caseStmt* "}" ;

caseStmt        ::= ( "case" expression ":" | "default" ":" ) declaration* ;

block           ::= "{" declaration* "}" ;

exprStmt        ::= expression ";" ;

expression      ::= assignment ;

assignment      ::= logicalOr ( "=" assignment )? ;

logicalOr       ::= logicalAnd ( "||" logicalAnd )* ;

logicalAnd      ::= bitwiseOr ( "&&" bitwiseOr )* ;

bitwiseOr       ::= bitwiseXor ( "|" bitwiseXor )* ;

bitwiseXor      ::= bitwiseAnd ( "^" bitwiseAnd )* ;

bitwiseAnd      ::= equality ( "&" equality )* ;

equality        ::= comparison ( ( "==" | "!=" ) comparison )* ;

comparison      ::= shift ( ( "<" | ">" | "<=" | ">=" ) shift )* ;

shift           ::= term ( ( "<<" | ">>" ) term )* ;

term            ::= factor ( ( "+" | "-" ) factor )* ;

factor          ::= unary ( ( "*" | "/" | "%" ) unary )* ;

unary           ::= ( "+" | "-" | "!" | "~" | "++" | "--" ) unary
                  | postfix ;

postfix         ::= call ( "++" | "--" )? ;

call            ::= primary ( "(" arguments? ")" )? ;

arguments       ::= expression ( "," expression )* ;

primary         ::= literal
                  | IDENTIFIER  
                  | "(" expression ")"
                  | ( "++" | "--" ) unary ;

literal         ::= INTLIT | FLOATLIT | BOOLLIT | STRINGLIT | CHARLIT ;

operator        ::= "+" | "-" | "*" | "/" | "%" | "=" | "==" | "!=" | "<" | ">" 
                  | "<=" | ">=" | "&&" | "||" | "!" | "&" | "|" | "^" | "~" 
                  | "<<" | ">>" | "++" | "--" | "(" | ")" | "{" | "}" | ";" 
                  | "," | "." | "[" | "]" ;