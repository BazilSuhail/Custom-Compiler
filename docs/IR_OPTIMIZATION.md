# Intermediate Representation (IR) Optimization

## Overview
The **IR Optimizer** is a critical component of the compilation pipeline that refines the raw **Three-Address Code (TAC)**. Its primary goal is to improve code efficiency, reduce memory footprint, and eliminate redundant computations without altering the program's semantic meaning.

Our optimizer operates on a linear sequence of TAC instructions and employs several standard compiler optimization passes in an iterative manner.

---

## Optimization Passes

### 1. Constant Folding
**Goal**: Evaluate expressions with constant operands at compile time.

- **Logic**: The optimizer scans for `Binary` instructions where both operands are literals (e.g., `Int`, `Float`). It performs the arithmetic operation during optimization and replaces the instruction with a simple assignment.
- **Example**:
    - **Source**: `int x = 10 * 2 + 5;`
    - **Raw TAC**:
      ```nginx
      t0 = 10 Multiply 2
      t1 = t0 Plus 5
      int x = t1
      ```
    - **Optimized TAC**:
      ```nginx
      int x = 25
      ```

### 2. Constant Propagation
**Goal**: Substitute variables known to be constants with their actual values.

- **Logic**: It maintains a tracking map (`HashMap`) of variables currently holding a literal value. When a variable is used as a source operand, it is replaced by its constant value.
- **Example**:
    - **Source**: `const int base = 10; int y = base + 5;`
    - **Raw TAC**:
      ```nginx
      const int base = 10
      t0 = base Plus 5
      int y = t0
      ```
    - **Optimized TAC**:
      ```nginx
      const int base = 10
      int y = 15
      ```

### 3. Copy Propagation
**Goal**: Eliminate redundant assignments where one variable is simply a copy of another.

- **Logic**: Tracks instances where `t2 = t1`. Subsequent uses of `t2` are replaced by `t1`. This reduces the number of active temporary variables and allows further optimization like DCE.
- **Example**:
    - **Source**: `int a = b; int c = a + 10;`
    - **Raw TAC**:
      ```nginx
      int a = b
      int copy = a
      t0 = copy Plus 10
      int c = t0
      ```
    - **Optimized TAC**:
      ```nginx
      int a = b
      t0 = b Plus 10
      int c = t0
      ```

### 4. Peephole Optimization
**Goal**: Simplify local instruction patterns and algebraic identities.

- **Logic**: Examines small windows of instructions for specific patterns:
    - **Algebraic Identities**: `x + 0 -> x`, `x * 1 -> x`, `x * 0 -> 0`, `x - x -> 0`.
    - **Jump Elimination**: Removes `goto L1` if it is immediately followed by `L1:`.
- **Example**:
    - **Source**: `int val = x * 1 + 0;`
    - **Raw TAC**:
      ```nginx
      t0 = x Multiply 1
      t1 = t0 Plus 0
      int val = t1
      ```
    - **Optimized TAC**:
      ```nginx
      int val = x
      ```

### 5. Dead Code Elimination (DCE)
**Goal**: Remove instructions whose results are never used.

- **Logic**: Uses a **Mark and Sweep** algorithm. 
    1. **Mark**: Scan the entire IR to identify which variables/temporaries are "used" as source operands.
    2. **Sweep**: Remove any `Assign`, `Binary`, or `Unary` instructions whose destination is not in the "used" set.
- **Safety**: Side-effecting operations like `print` and `call` are preserved, though a `call` return assignment may be stripped if the result is unused.
- **Example**:
    - **Source**: `int unused = 99; print(10);`
    - **Raw TAC**:
      ```nginx
      int unused = 99
      print 10
      ```
    - **Optimized TAC**:
      ```nginx
      print 10
      ```

---

## Optimization Procedure

To achieve maximum reduction, the optimizer runs these passes in a specific order:
1. **Constant Folding** -> Creates more constants for propagation.
2. **Constant Propagation** -> Replaces variables with constants.
3. **Copy Propagation** -> Simplifies chains of assignments.
4. **Peephole Optimization** -> Cleans up identities and jumps.
5. **Dead Code Elimination** -> Prunes all unused values generated by the previous steps.

This process is **iterative**. If any pass modifies the IR, the entire suite is re-run until a "fixed point" is reached (no more modifications).

---

## Full Transformation Example

**Source Input**:
```c
main {
    int folding = 10 * 2 + 5; 
    const int base = 10;
    int propagated = base + 15;
    int source = 100;
    int copy = source;
    int result = copy + 0;
    int dead = 999;
    print(result, propagated);
}
```

**Raw TAC (`tac.txt`)**:
```nginx
void main() begin:
t0 = 10 Multiply 2
t1 = t0 Plus 5
int folding = t1
const int base = 10
t2 = base Plus 15
int propagated = t2
int source = 100
int copy = source
t3 = copy Plus 0
int result = t3
int dead = 999
print result, propagated
end
```

**Optimized TAC (`optimized_tac.txt`)**:
```nginx
void main() begin:
int folding = 25
const int base = 10
int propagated = 25
int source = 100
print source, 25
end
```

*Note: In the optimized version, `dead` and `result` are eliminated, `copy` is propagated back to `source`, and all constant math is pre-solved.*