main {
    // 1. Constant Folding (Evaluates 10 * 2 + 5 -> 25)
    int folding = 10 * 2 + 5; 

    // 2. Constant Propagation (Replaces 'base' with 10)
    const int base = 10;
    int propagated = base + 5; 

    // 3. Copy Propagation (Replaces copy2 -> copy1 -> source)
    int source = 100;
    int copy1 = source;
    int copy2 = copy1;
    int result_copy = copy2 + 10; 

    // 4. Peephole Optimizations (Algebraic Identities)
    int val = 50;
    int p_add = val + 0;      // Should become: p_add = val
    int p_mul = p_add * 1;    // Should become: p_mul = val
    int p_zero = p_mul * 0;   // Should become: p_zero = 0
    int p_sub = val - val;    // Should become: p_sub = 0
    int p_div = val / 1;      // Should become: p_div = val

    // 5. Dead Code Elimination
    int dead_val = 999;       // This definition should disappear entirely
    int logic = result_copy + p_zero; // Note: p_zero becomes 0, so logic = result_copy

    // 6. Redundant Jump Elimination
    if (folding > 0) {
        print("Optimized logic reached:", logic);
    }

    print(logic);
}